import java.util.Random;

/**
 * A simple substitution cipher written for experimentation with the JVM,
 * and in particular to view the assembly instructions generated by the
 * HotSpot compiler. Arrays are the only data structures explicitly used
 * in this program.
 * 
 * @author Saint Wesonga
 */
public final class BasicSubstitutionCipher {

    private static final int zero = (int)'0';
    private static final int lowerA = (int)'a';
    private static final int upperA = (int)'A';
    private static final boolean verbose = false;

    // Enough space for 0-9, a-z, A-Z, and a space
    private static final int bufferSize = 63;

    public static void main(String[] args) {
        if (args.length < 1) {
            System.out.println("Usage: BasicSubstitutionCipher <MessageToEncrypt>");
            return;
        }

        if (args.length > 1) {
            System.out.println("Ignoring all arguments except the first");
        }

        char[] oneTimePad = createSubstitutionKey();
        String plaintext = args[0];

        System.out.println("Plaintext:  " + plaintext);
        System.out.println("oneTimePad: " + new String(oneTimePad));

        var ciphertext = encrypt(args[0], oneTimePad);
        System.out.println("Ciphertext: " + ciphertext);

        plaintext = decrypt(ciphertext, oneTimePad);
        System.out.println("Plaintext2: " + plaintext);
    }

    private static String encrypt(String plaintext, char[] oneTimePad) {
        var sb = new StringBuilder(plaintext.length());

        for (int i=0; i < plaintext.length(); i++)
        {
            char p = plaintext.charAt(i);
            int index = getOneTimePadIndexForPlainTextChar(p);

            char c = (index == -1) ? p : oneTimePad[index];

            sb.append(c);
        }
        return sb.toString();
    }

    private static String decrypt(String ciphertext, char[] oneTimePad) {
        var sb = new StringBuilder(ciphertext.length());

        for (int i=0; i < ciphertext.length(); i++)
        {
            char c = ciphertext.charAt(i);

            int indexOfCipherText = getIndexOfCipherTextCharInOneTimePad(c, oneTimePad);

            if (verbose) {
                System.out.println("indexOf(" + c + ") in oneTimePad: " + indexOfCipherText);
            }

            char p;
            if (indexOfCipherText == -1) {
                p = c;
            }
            else
            {
                p = getPlainTextCharFromOneTimePadIndex(indexOfCipherText);
                if (verbose) {
                    System.out.println("PlainTextCharFromOneTimePadIndex(" + indexOfCipherText + "): " + p);
                }
            }

            sb.append(p);
        }
        return sb.toString();
    }

    private static char getPlainTextCharFromOneTimePadIndex(int indexOfCipherText) {
        if (indexOfCipherText < 0 || indexOfCipherText >= bufferSize)
        {
            return 0;
        }

        if (indexOfCipherText <= 9)
        {
            return (char)(zero + indexOfCipherText);
        }

        if (indexOfCipherText <= 10 + ('z' - 'a'))
        {
            return (char)(lowerA + indexOfCipherText - 10);
        }

        if (indexOfCipherText <= 10 + 26 + ('Z' - 'A'))
        {
            return (char)(upperA + indexOfCipherText - 10 - 26);
        }

        return ' ';
    }

    private static int getIndexOfCipherTextCharInOneTimePad(char c, char[] oneTimePad) {
        for (int i=0; i < oneTimePad.length; i++)
        {
            if (oneTimePad[i] == c)
                return i;
        }

        return -1;
    }

    private static int getOneTimePadIndexForPlainTextChar(char c) {
        if (c >= '0' && c <= '9')
        {
            return ((int)c) - zero;
        }

        if (c >= 'a' && c <= 'z')
        {
            return 10 + ((int)c) - lowerA;
        }

        if (c >= 'A' && c <= 'Z')
        {
            return 10 + 26 + ((int)c) - upperA;
        }

        if (c == ' ')
        {
            return bufferSize - 1;
        }

        return -1;
    }

    private static char[] createSubstitutionKey()
    {
        char[] oneTimePad = new char[bufferSize];

        int i=0;
        for (; i < 10; i++) {
            oneTimePad[i] = (char)(zero + i);
        }

        for (int k=0; k < 26; k++) {
            oneTimePad[i++] = (char)(lowerA + k);
        }

        for (int k=0; k < 26; k++) {
            oneTimePad[i++] = (char)(upperA + k);
        }

        oneTimePad[bufferSize - 1] = ' ';

        shuffle(oneTimePad);

        return oneTimePad;
    }

    private static void shuffle(char[] oneTimePad) {
        var rand = new Random();

        // Observation: this approach does not map any index to itself!
        for (int i=oneTimePad.length-1; i > 0; i--)
        {
            int j = rand.nextInt(i);

            // swap values at offsets i and j
            char temp = oneTimePad[i];
            oneTimePad[i] = oneTimePad[j];
            oneTimePad[j] = temp;
        }
    }
}
